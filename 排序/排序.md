# 排序
## 选择排序
对于给定的一组记录，经过第一次排序得到最小的记录，然后和第一个记录交换位置；接着从第二个记录开始排序得到最小的记录，然后和第二个记录交换位置，以此类推：以
{38，65，97，76，13，27，49} 为例：  
第一遍：13[65，97，76，38，27，49]    
第二遍：13，27[97，76，38，65，49]  
第三遍：13，27，38[76，97，65，49]  
第四遍：13，27，38，49[97，65，76]  
... ...
```java
public void chooseSort(Integer[] a){
        for(int i=0;i<a.length;i++){
            int k = i;
            for(int j=i+1;j<a.length;j++){
                if(a[j] < a[k]){
                    k = j;
                }
            }
            if(k!=i){
                int tmp = a[k];
                a[k] = a[i];
                a[i] = tmp;
            }
        }
    }
```
## 插入排序
给定一组记录，初始第一个自成有序序列，其余为无序序列。接着从第二个记录开始，按照记录的大小依次插入之前的有序序列。仍以{38，65，97，76，13，27，49} 为例  
第一遍：[38] 65，97，76，13，27，49  
第二遍：[38，65] 97，76，13，27，49  
第三遍：[38，65，97] 76，13，27，49  
第四遍：[38，65，76，97] 13，27，49  
第五遍：[13，38，65，76，97] 27，49  
第六遍：[13，27，38，65，76，97] 49  
第七遍：[13，27，38，49，65，76，97]  
```java
public void insertSort(Integer[] a){
        for(int i=1;i<a.length;i++){
            int k = a[i];
            for(int j=i-1;j>=0;j--){
                if(a[j] > k){
                    int t = a[j+1];
                    a[j+1] = a[j];
                    a[j] = t;
                }else{
                    break;
                }
            }
        }
    }
```
## 冒泡排序
对于给定n个记录，从第一位开始相邻两两比较，比较大的和后面交换位置，则第一遍排序后最大的位于第n位置；以此类推进行n-1次排序。
```java
public void pubbleSort(Integer[] a){
        for(int i=0;i<a.length-1;i++){
            for(int j=0;j<a.length-1-i;j++){
                if(a[j]>a[j+1]){
                    int t = a[j];
                    a[j] = a[j+1];
                    a[j+1] = t;
                }
            }
        }
    }
```
## 归并排序
对于给定记录，首先将相邻的长度为1子序列进行归并，得到n/2个长度为2或1的有序子序列，接着相邻的子序列在进行归并以此重复执行，当记录只有一个子序列时排序结束。  

![](assets/排序-e810d276.png)
```java
public void mergeSort(Integer[] a) {
        stackMerge(a, 0, a.length - 1);
    }

    private void stackMerge(Integer[] a, int p, int r) {
        if (p < r) {
            int q = (r + p) / 2;
            stackMerge(a, p, q);
            stackMerge(a, q + 1, r);
            merge(a, p, q, r);
        }
    }

    private void merge(Integer[] a, int p, int q, int r) {
        int n = q - p + 1;
        int m = r - q;
        int[] L = new int[n];
        int[] R = new int[m];
        for (int i = p, k = 0; k < n; k++) {
            L[k] = a[i++];
        }
        for (int i = q + 1, k = 0; k <m; k++) {
            R[k] = a[i++];
        }
        int i = 0, j = 0;
        int k = p;
        for (; i < n && j < m; k++) {
            if (L[i] < R[j]) {
                a[k] = L[i++];
            } else {
                a[k] = R[j++];
            }
        }
        if (i < n) {
            for (; i < n; i++) {
                a[k++] = L[i];
            }
        }
        if (j < m) {
            for (; j < m; j++) {
                a[k++] = R[j];
            }
        }
    }
```
## 快速排序
对于给定记录通过一趟排序后，将记录分成两部分，其中前一部分的所有数据都小于后一部分，递归该过程直到序列中所有的记录均为有序序列为止.具体做法是设两个下标low和high,设枢轴为low下标的值pivotkey，然后从high所在的元素开始搜索，查找到第一个小于pivotkey然后互换位置，然后从low向后搜索找到第一个大于pivotkey的值和high交换位置，直到low=high时第一趟排序结束，依次再对pivotket左右两个序列进行递归排序。

![](assets/排序-c37627e3.png)

```java
public void quickSort(Integer[] a) {
        quickStackSort(a, 0, a.length - 1);
    }

    private void quickStackSort(Integer[] a, int low, int high) {
        if (low < high) {
            int p = partition(a, low, high);
            quickStackSort(a, low, p - 1);
            quickStackSort(a, p + 1, high);
        }
    }

    private int partition(Integer[] a, int low, int high) {
        int tmp = a[low];
        while (low < high) {
            while (low < high && a[high] >= tmp) high--;
            if (low < high) {
                a[low++] = a[high];
            }
            while (low < high && a[low] <= tmp) low++;
            if (low < high) {
                a[high++] = a[low];
            }
        }
        a[low] = tmp;
        return low;
    }
```
